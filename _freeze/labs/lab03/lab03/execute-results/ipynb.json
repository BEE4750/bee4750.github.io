{
  "hash": "65003038322cd74feca18a6ab10f2cf9",
  "result": {
    "markdown": "---\ntitle: 'BEE 4750 Lab 3: Linear Programming with JuMP'\nformat:\n  html:\n    warning: true\n    error: true\n    mermaid:\n      theme: forest\n  ipynb:\n    warning: true\n    error: true\n    code-annotation: below\nformat-links: []\n---\n\n::: {.content-visible when-format=\"ipynb\"}\n**Name**:\n\n**ID**:\n:::\n\n::: {.callout-important icon=\"false\"}\n### Due Date\n\nFriday, 10/13/23, 9:00pm\n:::\n\n::: {.content-visible when-format=\"html\"}\n::: callout-caution\nIf you are enrolled in the course, make sure that you use the GitHub Classroom link provided in Ed Discussion, or you may not be able to get help if you run into problems.\n\nOtherwise, you can [find the Github repository here](%7B%7B%3C%20var%20github_org.repo%20%3E%7D%7D/lab03).\n:::\n:::\n\n## Setup\n\nThe following code should go at the top of most Julia scripts; it will load the local package environment and install any needed packages. You will see this often and shouldn't need to touch it.\n\n::: {#aa69a624 .cell execution_count=1}\n``` {.julia .cell-code}\nimport Pkg\nPkg.activate(\".\")\nPkg.instantiate()\n```\n:::\n\n\n::: {#36efa2b9 .cell execution_count=2}\n``` {.julia .cell-code}\nusing JuMP # optimization modeling syntax\nusing HiGHS # optimization solver\nusing Plots # plotting\n```\n:::\n\n\n::: {.cell .markdown}\n## Overview\n\nIn this lab, you will write and solve a resource allocation example using `JuMP.jl`. `JuMP.jl` provides an intuitive syntax for writing, solving, and querying optimization problems.\n\nFor an example of using `JuMP.jl` to solve linear programs, see [the relevant tutorial on the class website](https://viveks.me/environmental-systems-analysis/tutorials/julia-jump.html).\n\nFree free to delete some of the illustrative cells and code blocks in your notebook as you go through and solve the lab problems...this might help reduce some potential confusion while grading about what your answer is.\n:::\n\n::: {.cell .markdown}\n## Introduction\n\nYour task is to decide how much lumber to produce to maximize profit from wood sales. You can purchase wood from a managed forest, which consists of spruce (320,000 bf) and fir (720,000 bf). Spruce costs \\$0.12 per bf to purchase and fir costs \\$0.08 per bf.\n\nAt the lumber mill, wood can be turned into plywood of various grades (see @tbl-inputs for how much wood of each type is required for and the revenue from each grade). Any excess wood is sent to be recycled into particle board. This resource allocation problem is diagrammed in @fig-schematic.\n\n\n| Plywood Grade | Inputs (bf/bf plywood) | Revenue (\\$/1000 bf) |\n|:-------------:|:----------------------:|:--------------------:|\n|       1       |   0.5 (S) + 1.5 (F)    |         400          |\n|       2       |   1.0 (S) + 2.0 (F)    |         520          |\n|       3       |   1.5 (S) + 2.0 (F)    |         700          |\n\n: Wood inputs and revenue by plywood grade. S refers to spruce inputs, F fir inputs. {#tbl-inputs}\n\n:::\n\n\n\n```{mermaid}\n%%| label: fig-schematic\n%%| fig-cap: \"Flowchat of the resource allocation problem in this lab.\"\n\nflowchart LR\n    A[Spruce] -- $0.12 per bf --> C{Lumber Mill}\n    B[Fir] -- $0.08 per bf --> C\n    C --> P(Plywood)\n    C -- Wood Excess --> D{Recycle}\n    P -- Price depends on grade --> S[Sell]\n```\n\n\n\n## Problems (10 points)\n\n::: {.cell .markdown}\n### Problem 1: Problem Formulation (5 points)\n\nIn this problem, you will go through the steps of formulating a linear program for this problem.\n:::\n\n::: {.cell .markdown}\n#### Problem 1.1 (1 point)\n\nWhat are your decision variables? Clearly define your notation, including what variables you are using, what they mean, and what their units are.\n:::\n\n::: {.cell .markdown}\n#### Problem 1.2 (1 point)\n\nDerive your objective function. Support your function with justifications and/or equations as necessary. You will not receive credit just for the function alone.\n:::\n\n::: {.cell .markdown}\n#### Problem 1.3 (2 point)\n\nDerive any needed constraints. Support your function with justifications and/or equations as necessary. You will not receive credit just for the final constraints alone.\n:::\n\n::: {.cell .markdown}\n#### Problem 1.4 (1 point)\n\nPut this optimization problem in mathematical programming form. For an example of the syntax for this, see lines 82--91 [here](https://github.com/vsrikrish/environmental-systems-analysis/blob/Fall23/tutorials/julia-jump.qmd).\n:::\n\n### Problem 2: Find the Solution (5 points)\n\n::: {.cell .markdown}\n#### Problem 2.1 (2 points)\n\nCode your linear program using `JuMP`. Feel free to consult [the website's `JuMP` tutorial](https://viveks.me/environmental-systems-analysis/tutorials/julia-jump.html) for syntax help. The keys:\n:::\n\n1.  Initialize your model with a solver; in this case, we'll use the `HiGHS` solver, but there are other solvers listed here for different types of problems, some of which are open and some of which require a commercial license: <https://jump.dev/JuMP.jl/stable/installation/#Supported-solvers>:\n\n\n    ::: {#6f1e5409 .cell execution_count=3}\n    ``` {.julia .cell-code}\n    example_model = Model(HiGHS.Optimizer)\n    ```\n    :::\n    \n    \n2.  Define variables with syntax like\n\n\n    ::: {#b311b582 .cell execution_count=4}\n    ``` {.julia .cell-code}\n    @variable(example_model, 1 >= example_x >= 0)\n    ```\n    :::\n    \n    \n    This will create a variable `example_x` which is constrained to be between 0 and 1; you can leave off any of the bounds if a variable is unbounded in a particular direction. You can also add a vector of variables:\n\n\n    ::: {#e545ce09 .cell execution_count=5}\n    ``` {.julia .cell-code}\n    T = 1:3 # define set to index variables\n    @variable(example_model, 1 >= example_z[t in T] >= 0)\n    ```\n    :::\n    \n    \n    which will create a vector of 3 variables `example_z[1]`, ..., `example_z[3]`, all of which are bounded between 0 and 1.\n\n3.  Add an objective with\n\n\n    ::: {#b84acc1f .cell execution_count=6}\n    ``` {.julia .cell-code}\n    @objective(example_model, Max, example_x + sum(example_z))\n    ```\n    :::\n    \n    \n    which will add an objective to maximize (replace with `Min` to minimize).\n\n4.  Add constraints:\n\n\n    ::: {#53afba14 .cell execution_count=7}\n    ``` {.julia .cell-code}\n    @constraint(example_model, constraint1, 2example_x + 3*sum(example_z) <= 10)\n    @constraint(example_model, constraint2, 5example_x - example_z[1] <= 2)\n    ```\n    :::\n    \n    \n    which will name the constraints `constraint1` and `constraint2` (you should make yours more descriptive about what the constraint actually is). The value of adding a name is to facilitate later querying of shadow prices, which we will discuss later. You can also add a vector of constraints which have similar structure or rely on different elements of a data vector:\n\n\n    ::: {#e61058f5 .cell execution_count=8}\n    ``` {.julia .cell-code}\n    A = [2; 4]\n    b = [8; 12]\n    I = 1:2 # set indices for constraint\n    @constraint(example_model, vector_constraint[i in I], A[i] * sum(example_z) .<= b[i])\n    ```\n    :::\n    \n    \n    You can also define matrices of constraints which depend on two index sets by generalizing this syntax, e.g.\n\n    ``` julia\n    @constraint(example_model, matrix_constraint[i in I, j in J, ...])\n    ```\n\n    ::: {.callout-tip} \n    Specifying higher-dimensional vectors and matrices of variables and constraints will be important when we start looking at more complex applications, so don't skip over this! You don't want to manually enter thousands of constraints to ensure hourly electricity demand is met... \n    :::\n\n    Finally, you can (and probably should) `print` your model to make sure that you get something that looks like the equations that you wrote down (in a notebook, this will be nicely rendered):\n\n\n    ::: {#41aa515f .cell execution_count=9}\n    ``` {.julia .cell-code}\n    print(example_model)\n    ```\n    \n    ::: {.cell-output .cell-output-display}\n    $$ \\begin{aligned}\n    \\max\\quad & example\\_x + example\\_z_{1} + example\\_z_{2} + example\\_z_{3}\\\\\n    \\text{Subject to} \\quad & 2 example\\_x + 3 example\\_z_{1} + 3 example\\_z_{2} + 3 example\\_z_{3} \\leq 10\\\\\n     & 5 example\\_x - example\\_z_{1} \\leq 2\\\\\n     & 2 example\\_z_{1} + 2 example\\_z_{2} + 2 example\\_z_{3} \\leq 8\\\\\n     & 4 example\\_z_{1} + 4 example\\_z_{2} + 4 example\\_z_{3} \\leq 12\\\\\n     & example\\_x \\geq 0\\\\\n     & example\\_z_{1} \\geq 0\\\\\n     & example\\_z_{2} \\geq 0\\\\\n     & example\\_z_{3} \\geq 0\\\\\n     & example\\_x \\leq 1\\\\\n     & example\\_z_{1} \\leq 1\\\\\n     & example\\_z_{2} \\leq 1\\\\\n     & example\\_z_{3} \\leq 1\\\\\n    \\end{aligned} $$\n    :::\n    :::\n    \n    \n    ::: {.callout-tip} \n    ## Define your entire model in one cell\n\n    `JuMP` has great and intuitive syntax, but it doesn't like re-defining variables or constraints once they've been set. I recommend putting all of your model-definition code (starting from `model = Model(...)`) for a particular optimization problem in a single notebook cell, so you can re-set up the entire problem with a single click when you want to make a change. \n    :::\n\n::: {.cell .markdown}\n#### Problem 2.2 (1 points)\n\nFind the solution to your program and find the optimal values of the decision variables. Once you've defined your model, you can find the solution with \\`optimize!():\n:::\n\n::: {#37d01b73 .cell execution_count=10}\n``` {.julia .cell-code}\noptimize!(example_model)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning HiGHS 1.5.3 [date: 1970-01-01, git hash: 45a127b78]\nCopyright (c) 2023 HiGHS under MIT licence terms\nPresolving model\n2 rows, 4 cols, 6 nonzeros\n2 rows, 3 cols, 5 nonzeros\n2 rows, 3 cols, 5 nonzeros\nPresolve : Reductions: rows 2(-2); columns 3(-1); elements 5(-7)\nSolving the presolved LP\nUsing EKK dual simplex solver - serial\n  Iteration        Objective     Infeasibilities num(sum)\n          0     0.0000000000e+00 Ph1: 0(0) 0s\n          2    -3.5333333333e+00 Pr: 0(0) 0s\nSolving the original LP from the solution after postsolve\nModel   status      : Optimal\nSimplex   iterations: 2\nObjective value     :  3.5333333333e+00\nHiGHS run time      :          0.00\n```\n:::\n:::\n\n\n::: callout-note\n## What if I Get An Error?\n\nIf `optimize!()` throws an error, that's usually a sign that something is wrong with the formulation (for example, a variable might not be bounded or a constraint might not be specified correctly) or a typo in the model definition. Linear programs should be well behaved!\n:::\n\nTo find the values of variables after optimizing, use `value.()` (the broadcasting ensures this will work for vector-valued variables as well):\n\n::: {#d10c924f .cell execution_count=11}\n``` {.julia .cell-code}\nvalue.(example_x)\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n0.6\n```\n:::\n:::\n\n\n::: {#0aa88031 .cell execution_count=12}\n``` {.julia .cell-code}\nvalue.(example_z)\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n1-dimensional DenseAxisArray{Float64,1,...} with index sets:\n    Dimension 1, 1:3\nAnd data, a 3-element Vector{Float64}:\n 1.0\n 0.9333333333333332\n 1.0\n```\n:::\n:::\n\n\n::: {.cell .markdown}\n#### Problem 2.3 (1 point)\n\nHow would your profit change if you could buy 1,000 additional bf of spruce? You can answer this by getting the shadow price of a particular variable with:\n:::\n\n::: {#098eca5e .cell execution_count=13}\n``` {.julia .cell-code}\nshadow_price(constraint1) # this is why we named the constraints when we defined them\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n0.3333333333333333\n```\n:::\n:::\n\n\n::: {.cell .markdown}\n#### Problem 2.4 (1 point)\n\nWould you prefer to have 2,000 additional bf of spruce or 1,000 additional bf of fir?\n:::\n\n## References\n\nPut any consulted sources here, including classmates you worked with/who helped you.\n\n---\njupyter:\n  kernelspec:\n    display_name: Julia 1.9.2\n    language: julia\n    name: julia-1.9\n  language_info:\n    file_extension: .jl\n    mimetype: application/julia\n    name: julia\n    version: 1.9.2\n---\n",
    "supporting": [
      "lab03_files/figure-ipynb"
    ],
    "filters": []
  }
}