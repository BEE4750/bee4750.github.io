{
  "hash": "f4762df815b16b76d218cb6c6aaaf8b2",
  "result": {
    "markdown": "---\ntitle: BEE 4750 Lab 2 Solution\nformat:\n  html:\n    warning: true\n    error: true\n  pdf:\n    warning: true\n    error: true\n    code-annotation: below\nformat-links: []\n---\n\n## Setup\n\nThe following code should go at the top of most Julia scripts; it will load the local package environment and install any needed packages. You will see this often and shouldn't need to touch it.\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nimport Pkg\nPkg.activate(\".\")\nPkg.instantiate()\n```\n:::\n\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\nusing Random # random number generation\nusing Distributions # probability distributions and interface\nusing Statistics # basic statistical functions, including mean\nusing Plots # plotting\n```\n:::\n\n\n## Exercises (10 points)\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\nRandom.seed!(1)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\nTaskLocalRNG()\n```\n:::\n:::\n\n\n### Problem 1 (5 points)\n\nWe want to know the probability of getting at least an 11 from rolling three fair, six-sided dice (this is actually an old Italian game called *passadieci*, which was analyzed by Galileo as one of the first examples of a rigorous study of probability).\n\n#### Problem 1.1 (1 point)\n\nWrite a function called `passadieci()` to simulate this game, which will take as an input the number of realizations and output a vector of the sum of the three dice rolls for each realization.\n\n***Solution***:\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\n# n is the number of realizations\nfunction passadieci(n)\n    outcomes = zeros(n) # initialize storage for realizations\n    for i = 1:n\n        dice_dist = DiscreteUniform(1, 6) # create dice roll distribution\n        outcomes[i] = sum(rand(dice_dist, 3)) # add three draws from the distribution\n    end\n    return outcomes\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\npassadieci (generic function with 1 method)\n```\n:::\n:::\n\n\n### Problem 1.2 (2 points)\n\nGenerate 5,000 simulations of the game using your `passadieci()` function. Plot how the computed probability of winning the game changes as the number of simulations increases (you can do this by computing the frequency of wins for each additional simulation).\n\n***Solution***:\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\npassadieci_sims = passadieci(5000) # simulation\n# compute running number of wins\nwins = passadieci_sims .>= 11 # translate dice rolls into wins\nwin_freq = zeros(length(passadieci_sims)) \n# compute average number of wins by looping over and adding the impact of the next game\nfor (i, next_win) in pairs(wins)\n    if i == 1\n        win_freq[i] == next_win\n    else\n        win_freq[i] = (win_freq[i-1] * (i-1) + next_win) / i\n    end\nend\n# make plot\nplot(win_freq, xlabel=\"Simulation Number\", ylabel=\"Running Win Frequency\")\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n![](lab02-solution_files/figure-pdf/cell-6-output-1.svg){fig-pos='H'}\n:::\n:::\n\n\n### Problem 1.3 (2 point)\n\nBased on your plot from Problem 1.2, how many simulations were needed for the win probability estimate to converge? What did you notice from your plot about the estimates prior to convergence?\n\n***Solution***:\n\nThe probability sememed to converge after around 1,500--2,000 simulations. We can see that the estimates are relatively noisy prior to this point, even if the overall trend is to move towards the eventual average.\n\n## Problem 2 (5 points)\n\nThe Showcase is the final round of every episode of The Price is Right, matching the two big winners from the episode. Each contestant is shown a \"showcase\" of prizes, which are usually some combination of a trip, a motor vehicle, some furniture, and maybe some other stuff. They then each have to make a bid on the retail price of the showcase. The rules are:\n\n* an overbid is an automatic loss;\n* the contest who gets closest to the retail price wins their showcase;\n* if a contestant gets within \\$250 of the retail price and is closer than their opponent, they win both showcases.\n\nYour goal is to find a wager which maximizes your expected winnings, which we may as well call utility, based on your assessment of the probability of your showcase retail price. \n\nWe'll assume that the distribution of all showcases offered by the show is given as truncated normal distribution, which means a normal distribution which has an upper and/or lower bound. `Distributions.jl` makes it easy to specify truncations on any distribution, not just normal distributions. For example, we'll use this distribution for the showcase values:\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\nshowcase_dist = truncated(Normal(31000, 4500), lower=5000, upper=42000)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\nTruncated(Normal{Float64}(μ=31000.0, σ=4500.0); lower=5000.0, upper=42000.0)\n```\n:::\n:::\n\n\n#### Problem 2.1 (3 points)\n\nWrite a function `showcase()` which takes in a bid value and uses Monte Carlo simulation to compute the expected value of the winnings. Make the following assumptions about your expected winnings if you don't overbid:\n\n* If you win both showcases, the value is the double of the single showcase value. \n* If you did not win both showcases but bid under the showcase value, the probability of being outbid increases linearly as the distance between your bid and the value increases (in other words, if you bid the exact value, you win with probability 1, and if you bid \\$0, you win with probability 0).\n\nHow did you decide how many samples to use within the function?\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\n# the syntax (...; param=val) is used for optional\n# arguments, which are given a default. these arguments must be\n# named in subsequent calls if they are changed, as we will see below.\nfunction showcase(bid; nsamples = 500000)\n    samples = rand(showcase_dist, nsamples)\n    winnings = 0 # running total of winnings over the simulations\n    for (i, value) in pairs(samples)\n        if 0 < (value - bid) < 250\n            winnings += 2 * value\n        elseif bid < value\n            p_win = bid / value\n            winnings += value * p_win\n        end\n    end\n    # return expected winnings\n    return winnings / nsamples\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\nshowcase (generic function with 1 method)\n```\n:::\n:::\n\n\nOne could justify the number of samples by looking at the plot of the Monte Carlo estimate as additional samples are created (for example, analogously to Problem 1.2). However, this should not be done arbitrarily.\n\n#### Problem 2.2 (2 points)\n\nPlot the expected winnings for bids ranging from \\$0 to \\$42,000. What do you notice?\n\n***Solution***:\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\nbids = 0:500:42000\nexpected_winnings = showcase.(bids)\nplot(bids, expected_winnings, xlabel=\"Showcase Bid (\\$)\", ylabel=\"Expected Winnings (\\$)\", label=:false)\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n![](lab02-solution_files/figure-pdf/cell-9-output-1.svg){fig-pos='H'}\n:::\n:::\n\n\nThe bid is maximized around \\$25,000, which we can see with the following code:\n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\n# get index 2 from findmax, which returns both the value and the index of the maximum\nbest_idx = findmax(expected_winnings)[2]\nbids[best_idx]\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n25000\n```\n:::\n:::\n\n\nFinding this value explicitly was not required, but at least some analysis of the plot would be useful! More than that starts to increase the risk of an overbid, while less than that and we open up space for our opponent to outbid us. Due to the asymmetry of the problem, the dropoff from the \"best\" bid is quite rapid; this is similar to when we have a strong constraint on an environmental system (such as a regulatory limit) and there can be a large penalty for exceeding it.\n\nAlso, this is a point where if we had used too few samples in Problem 2.2, we might have noticed that our plot would be less smooth than expected due to the lack of convergence. This could distort our analysis of the resulting plot/simulations.\n\n## References\n\nPut any consulted sources here, including classmates you worked with/who helped you.\n:::\n\n",
    "supporting": [
      "lab02-solution_files/figure-pdf"
    ],
    "filters": []
  }
}