{
  "hash": "935574c7633a4e9b7e750a92b704afc8",
  "result": {
    "engine": "julia",
    "markdown": "---\ntitle: \"Homework 3 Solutions\"\nformat:\n    html:        \n        warning: true\n        error: true\n    ipynb:\n        warning: true\n        error: true\n        code-annotation: below\n    pdf:\n        include-in-header: \n           text: |\n            \\usepackage{fvextra}\n            \\DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\\\\{\\}}\n            \\DefineVerbatimEnvironment{OutputCode}{Verbatim}{breaklines,commandchars=\\\\\\{\\}}\nengine: julia\nformat-links: [pdf, ipynb]\n---\n\n\n\n\n\n\n\n\n::: {.content-visible when-format=\"ipynb\"}\n**Name**:\n\n**ID**:\n:::\n\n::: {.callout-important icon=false}\n### Due Date\n\nThursday, 10/03/23, 9:00pm\n:::\n\n::: {.content-visible when-format=\"html\"}\n\n:::{.callout-caution}\n\nIf you are enrolled in the course, make sure that you use the GitHub Classroom link provided in Ed Discussion, or you may not be able to get help if you run into problems.\n\nOtherwise, you can [find the Github repository here]({{< var github_org.repo >}}/hw03).\n\n:::\n\n:::\n\n## Overview\n\n### Load Environment\n\nThe following code loads the environment and makes sure all needed packages are installed. This should be at the start of most Julia scripts.\n\n\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nimport Pkg\nPkg.activate(@__DIR__)\nPkg.instantiate()\n```\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing Random\nusing CSV\nusing DataFrames\nusing Plots\nusing LaTeXStrings\nusing Distributions\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## Problems (Total: 50/60 Points)\n\n\n::: {.cell .markdown}\n\n### Problem 1 (30 points)\n\nThe first step is to write function(s) to implement the dissolved oxygen simulation. With two releases, we can turn this into a two-box model, with the first box from the initial waste release ($x=0\\ \\text{km}$) to the second release ($x=15\\ \\text{km}$), and the second from the second release to the end of the domain ($x=50\\ \\text{km}$). As a result, our lives will be easiest if we write a function to simulate each box with appropriate initial conditions, which we can then call for each river segment. An example of how this might look is below. Note that we need to compute B and N as well to get the appropriate initial conditions at the transition between boxes (and this might also help with debugging).\n\n\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n# mix_concentration: function to compute initial conditions by mixing inflow and new waste stream concentrations\n# inputs:\n#   - arguments ending in \"_in\" are inflow, those ending in \"_st\" are from the stream\n#   - V is the volume (L/d), Q is the relevant concentration (mg/L); these should be Floats\n# outputs:\n#   - mixed concentration (a Float) in mg/L\nfunction mix_concentration(V_in, Q_in, V_st, Q_st)\n    Q_mix = ((V_in * Q_in) + (V_st * Q_st)) / (V_in + V_st)\n    return Q_mix\nend\n\n# dissolved_oxygen: function to simulate dissolved oxygen concentrations for a given segment\n# inputs:\n#   - x: vector or range of downstream distances to simulate over\n#   - C₀, B₀, N₀: initial conditions for DO, CBOD, and NBOD, respectively (mg/L)\n#   - U: velocity of river (km/d)\n#   - Cₛ = saturation oxygen concentration (mg/L)\n#   - ka, kc, kn: reaeration, CBOD decay, and NBOD decay rates, respectively (d^{-1})\nfunction dissolved_oxygen(x, C₀, B₀, N₀, U, Cₛ, ka, kc, kn)\n\n    # initialize vectors for C, B, and N\n    # the zeros function lets us define a vector of the appropriate length with values set to zero\n    C = zeros(length(x))\n    B = zeros(length(x))\n    N = zeros(length(x))\n\n    # compute α values for the simulation\n    α₁ = exp.(-ka * x / U) # <1>\n    α₂ = (kc / (ka - kc)) * (exp.(-kc * x / U) .- α₁) # <1>\n    α₃ = (kn / (ka - kn)) * (exp.(-kn * x / U) .- α₁) # <1>\n\n    # loop over values in x to calculate B, N, and C\n    for (i, d) in pairs(x) # <2>\n        B[i] = B₀ * exp(-kc * x[i] / U)\n        N[i] = N₀ * exp(-kn * x[i] / U)\n        C[i] = Cₛ * (1 - α₁[i]) + (C₀ * α₁[i]) - (B₀ * α₂[i]) - (N₀ * α₃[i])\n    end\n\n    return (C, B, N) # <3>\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ndissolved_oxygen (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n1. These will be vectors due to the broadcasting of `exp` and `-` over the `x` vector. We could also have computed the `α` values in the loop below for each value of `x`.\n2. `pairs(x)` lets us directly iterate over indices (`i`) and values (`d`) in the vector `x`, rather than only iterating over indices and needing to look up the values `d=x[i]`.\n3. While we don't need `B` and `N` for this solution, returning this tuple can be useful for debugging.\n\nNext, let's simulate the concentrations. Hopefully this is intuitive, but one critical thing is that we need to compute the initial segment from $x=0$ to $15\\ \\text{km}$, not just to 14, as $x=15$ is the inflow for the initial condition of the segment after the second waste stream. \n\n\n::: {.callout-note}\nI initially wrote this out as a script to debug, but then reformulated it as a function with an optional parameters for treatment of the two waste streams to solve Problems 2 and 3, which means I didn't have to copy and paste everything, possibly introducing new bugs.\n:::\n\n\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n# do_simulate: function to simulate dissolved oxygen concentrations over the entire river\n# inputs:\n#   - inflow: tuple with inflow properties: (Volume, DO, CBOD, NBOD)\n#   - waste1: tuple with waste stream 1 properties: (Volume, DO, CBOD, NBOD)\n#   - waste2: tuple with waste stream 2 properties: (Volume, DO, CBOD, NBOD)\n#   - U: velocity of river (km/d)\n#   - Cₛ = saturation oxygen concentration (mg/L)\n#   - ka, kc, kn: reaeration, CBOD decay, and NBOD decay rates, respectively (d^{-1})\nfunction do_simulate(inflow, waste1, waste2, U, Cₛ, ka, kc, kn)\n    # set up ranges for each box/segment\n    x₁ = 0:1:15 # <1>\n    x₂ = (15:1:50) .- 15 # <2>\n\n    V_inflow, C_inflow, B_inflow, N_inflow = inflow # <3>\n    V_ws1, C_ws1, B_ws1, N_ws1 = waste1 # <3>\n    V_ws2, C_ws2, B_ws2, N_ws2 = waste2 # <3>\n\n    # initialize storage for final C, B, and N\n    # need to store d=0 so the total length should be d+1\n    C = zeros(51)\n    B = zeros(51)\n    N = zeros(51)\n\n    # compute initial conditions for first segment\n    C₀ = mix_concentration(V_inflow, C_inflow, V_ws1, C_ws1)\n    B₀ = mix_concentration(V_inflow, B_inflow, V_ws1, B_ws1)\n    N₀ = mix_concentration(V_inflow, N_inflow, V_ws1, N_ws1)\n\n    # conduct first segment simulation\n    (C₁, B₁, N₁) = dissolved_oxygen(x₁, C₀, B₀, N₀, U, Cₛ, ka, kc, kn)\n    C[1:15] = C₁[1:end-1] # <4>\n    B[1:15] = B₁[1:end-1]\n    N[1:15] = N₁[1:end-1]\n\n    # compute initial conditions for second segment\n    C₀₁ = mix_concentration(V_inflow + V_ws1, C₁[end], V_ws2, C_ws2)\n    B₀₁ = mix_concentration(V_inflow + V_ws1, B₁[end], V_ws2, B_ws2)\n    N₀₁ = mix_concentration(V_inflow + V_ws1, N₁[end], V_ws2, N_ws2)\n\n    # conduct second segment simulation\n    (C₂, B₂, N₂) = dissolved_oxygen(x₂, C₀₁, B₀₁, N₀₁, U, Cₛ, ka, kc, kn)\n    C[16:end] = C₂\n    B[16:end] = B₂\n    N[16:end] = N₂\n\n    return (C, B, N)\nend\n\n# set variables for river dynamics\nU = 6\nCₛ = 10\nka = 0.55\nkc = 0.35\nkn = 0.25\n\n# set initial parameters\nC_inflow = 7.5 # DO concentration\nB_inflow = 5.0 # CBOD\nN_inflow = 5.0 # NBOD\nV_inflow = 100 * 1_000 # volume converted to L\ninflow = (V_inflow, C_inflow, B_inflow, N_inflow)\n\n# set waste stream parameters\nC_ws1 = 5.0\nB_ws1 = 50.0\nN_ws1 = 35.0\nV_ws1 = 10 * 1_000\nwaste1 = (V_ws1, C_ws1, B_ws1, N_ws1)\n\nC_ws2 = 4.0\nB_ws2 = 45.0\nN_ws2 = 35.0\nV_ws2 = 15 * 1_000\nwaste2 = (V_ws2, C_ws2, B_ws2, N_ws2)\n\nC, B, N = do_simulate(inflow, waste1, waste2, U, Cₛ, ka, kc, kn)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n([7.2727272727272725, 6.718366940001292, 6.252736478441488, 5.865982487427475, 5.549224625451668, 5.294464471079079, 5.094502688374758, 4.942863751725384, 4.8337275512230455, 4.761867260163488  …  5.965177734979926, 6.111409254214727, 6.254932119301499, 6.395478206784325, 6.532828783895545, 6.66680882593059, 6.797281903682192, 6.924145587090053, 7.047327316192408, 7.166780694952493], [9.090909090909092, 8.575776817031748, 8.089834281709308, 7.63142746153825, 7.198996057607107, 6.791068184640297, 6.4062553610792135, 6.043247783048131, 5.700809866118693, 5.377776039698319  …  1.916804331604075, 1.8081894764731885, 1.7057292332453498, 1.6090748536058688, 1.5178973509064155, 1.4318863803790853, 1.350749182802631, 1.274209588025372, 1.2020070749530312, 1.1338958848019383], [7.7272727272727275, 7.411918532206977, 7.109434113044771, 6.819294247244602, 6.540995146882018, 6.27405358389127, 6.018006051006311, 5.772407956944252, 5.536832854433826, 5.3108716997484215  …  2.653493696687388, 2.5452031783680957, 2.4413320548913466, 2.3416999683543676, 2.246133921358312, 2.1544679766220987, 2.0665429688551744, 1.9822062283889013, 1.9013113160867028, 1.8237177690726656])\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n1. The colon syntax sets up the range using the syntax `initial_value:stepsize:end_value`. In general a stepsize of 1 is implicit, but I've made it explicit here for illustration.\n2. This starts at 0 because we care about the distance from the initial condition, not the \"absolute\" distance.\n3. Tuples (including multiple outputs from functions) can be unpacked into multiple variables this way to make the subsequent code more readable (versus just relying on indexing).\n4. We don't need to store the last value because that occurs at the point of mixing with the next waste stream. We will use it to compute the mixed concentration at that point.\n\nNow we can plot the dissolved oxygen concentration, shown in @fig-do-untreated.\n\n\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n# create plot axis with labels, etc\np = plot(; xlabel=\"Distance Downriver (km)\", ylabel=\"Dissolved Oxygen Concentration (mg/L)\", legend=:top) # <1>\nplot!(p, 0:50, C, label=\"Simulated DO\") # <1>\nhline!([4], label=\"Regulatory Standard\")\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n![Simulated dissolved oxygen concentration for Problem 1 without treatment.](hw03_files/figure-pdf/fig-do-untreated-output-1.svg){#fig-do-untreated fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n\n\n\n1. These lines of code separate the creation of the plot axis (with labels, legend positions, etc) using `p = plot(...)` from the plotting of the data with `plot!(p, ...)`. You can do this all in a single `plot()` call, but this may sometimes make things more readable when there are a lot of style arguments for the axes. \n\nWe can see that the DO concentration falls below the regulatory standard of 4 mg/L before 20 km downstream. To find the minimum value, we can use the `minimum()` function.\n\n\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n@show minimum(C);\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nminimum(C) = 3.694312052808094\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nSo the minimum value is 3\\.7 mg/L.\n\nTo determine the minimum treatment of the waste streams needed to maintain compliance, we will write a function which will apply treatment levels `eff1` and `eff2` and evaluate our function above, returning the minimum DO concentration.\n\n\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n# waste_treat: function to simulate DO with treated discharges; treatments apply to CBOD and NBOD released\n# inputs:\n#   - eff1: efficiency of treatment for waste stream 1 (as a decimal)\n#   - eff2: efficiency of treatment for waste stream 2 (as a decimal)\n#   - inflow: tuple with inflow properties: (Volume, DO, CBOD, NBOD)\n#   - waste1: tuple with waste stream 1 properties: (Volume, DO, CBOD, NBOD)\n#   - waste2: tuple with waste stream 2 properties: (Volume, DO, CBOD, NBOD)\n#   - U: velocity of river (km/d)\n#   - Cₛ = saturation oxygen concentration (mg/L)\n#   - ka, kc, kn: reaeration, CBOD decay, and NBOD decay rates, respectively (d^{-1})\nfunction waste_treat(eff1, eff2, inflow, waste1, waste2, U, Cₛ, ka, kc, kn)\n    waste1_treated = (waste1[1], waste1[2], (1 - eff1) * waste1[3], (1 - eff1) * waste1[4])    \n    waste2_treated = (waste2[1], waste2[2], (1 - eff2) * waste2[3], (1 - eff2) * waste2[4])    \n    C, B, N = do_simulate(inflow, waste1_treated, waste2_treated, U, Cₛ, ka, kc, kn)\n    return minimum(C)\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nwaste_treat (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nNow we can evaluate this function over a range of treatment efficiencies. There are a number of ways to do this, but we'll use a trick which Julia makes easy: broadcasting using an anonymous function. \n\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n# evaluate treatment efficiencies between 0 and 1\neffs = 0:0.01:1\ntreat1 = (e1 -> waste_treat(e1, 0, inflow, waste1, waste2, U, Cₛ, ka, kc, kn)).(effs)\ntreat2 = (e2 -> waste_treat(0, e2, inflow, waste1, waste2, U, Cₛ, ka, kc, kn)).(effs)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n101-element Vector{Float64}:\n 3.694312052808094\n 3.715106569604958\n 3.7359010864018223\n 3.7566956031986853\n 3.7774901199955497\n 3.7982846367924123\n 3.819079153589276\n 3.8398736703861394\n 3.8606681871830038\n 3.8814627039798673\n ⋮\n 4.711700098308851\n 4.711700098308851\n 4.711700098308851\n 4.711700098308851\n 4.711700098308851\n 4.711700098308851\n 4.711700098308851\n 4.711700098308851\n 4.711700098308851\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nTo find the minimum treatment level which ensures compliance, we can now find the position of the first value where the minimum value is at least 4 mg/L, and look up the associated efficiency. Julia provides the `findfirst()` function which lets you find the index of the first value satisfying a Boolean condition.\n\n\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n# find indices and treatment values\nidx1 = findfirst(treat1 .>= 4.0)\nidx2 = findfirst(treat2 .>= 4.0)\n@show effs[idx1];\n@show effs[idx2];\n```\n\n::: {.cell-output .cell-output-stdout}\n```\neffs[idx1] = 0.19\neffs[idx2] = 0.15\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nSo the minimum treatment level for waste stream 1 is 19% and the minimum treatment level for waste stream 2 is 15%.\n\nThere is no \"right\" answer to the question of which treatment option you would pick, so long as your solution is thoughtful and justified. \n\n* For example, one could argue that as waste stream 1 on its own does not result in a lack of compliance (which we can see from @fig-do-untreated, as the initial \"sag\" has started to recover prior to waste stream 2), waste stream 2 ought to be treated. \n* On the other hand, waste stream 1 has a much more negative impact on the inflow dissolved oxygen levels, and waste stream 2 might not cause a lack of compliance without that effect, which might suggest that waste stream 1 should be treated.\n* Another consideration might be the relative cost of treating each waste stream, which we have no information on, or whether these waste streams are from municipal, residual, or industrial sources (in other words, non-profit vs. profit).\n\n### Problem 2 (20 points)\n\nLoading the data:\n\n\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n# Dataset from https://zenodo.org/record/3973015\n# The CSV is read into a DataFrame object, and we specify that it is comma delimited\nforcings_all = CSV.read(\"data/ERF_ssp585_1750-2500.csv\", DataFrame, delim=\",\")\n\n# Separate out the individual components\n# Get total aerosol forcings\nforcing_aerosol_rad = forcings_all[!,\"aerosol-radiation_interactions\"]\nforcing_aerosol_cloud = forcings_all[!,\"aerosol-cloud_interactions\"]\nforcing_aerosol = forcing_aerosol_rad + forcing_aerosol_cloud\n# Calculate non-aerosol forcings from the total.\nforcing_total = forcings_all[!,\"total\"]\nforcing_non_aerosol = forcing_total - forcing_aerosol\nt = Int64.(forcings_all[!,\"year\"])\nidx_2100 = findfirst(t .== 2100) # find the index which corresponds to the year 2100\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n351\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nThe energy balance model is given by $$cd \\frac{dT}{dt} = F - \\lambda T.$$ Discretizing with Forward Euler, we get\n$$\n\\begin{aligned}\ncd\\frac{T(t + \\Delta t) - T(t)}{\\Delta t} &= F(t) - \\lambda T(t) \\\\\nT(t + \\Delta t) &= T(t) + \\frac{\\Delta t}{cd} \\left(F(t) - \\lambda T(t)\\right).\n\\end{aligned}\n$$\n\nIn Julia code (and with the assumed parameter values), this becomes the following function (replacing $F(t) = F_\\text{nonaerosol} + \\alpha F_\\text{aerosol}$):\n\n\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n# ebm: function to simulate the energy balance model\n# inputs:\n#   - t: vector of time values.\n#   - F_nonaerosol: vector of non-aerosol radiative forcing values\n#   - F_aerosol: vector of aerosol radiative forcing values\n#   - c, d, λ, α, Δt: model parameters, see below.\nfunction ebm(t, F_nonaerosol, F_aerosol, c, d, λ, α, Δt)\n    T = zeros(length(t)) # <1>\n    F = F_nonaerosol + α * F_aerosol\n    for s in 1:length(t)-1 # <2>\n        T[s+1] = T[s] + Δt * (F[s] - λ * T[s]) / (c * d)\n    end\n    return T\nend\n\nc = 4.184e6 # specific heat of water, J/K/m^2\nd = 86 # ocean mixing depth, m\nλ = 2.1 # climate feedback factor\nα = 0.8 # aerosol scaling factor\nΔt = 31_558_152 # annual time step, s\n\ntemps = ebm(t, forcing_non_aerosol, forcing_aerosol, c, d, λ, α, Δt)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n751-element Vector{Float64}:\n 0.0\n 0.022731483349329427\n 0.040278289494741326\n 0.05240826578450054\n 0.05895069636157351\n 0.06063584224928685\n 0.058278631700672184\n 0.036311110702349894\n 0.03060499874837628\n 0.03778068117354878\n ⋮\n 6.0349064449781515\n 6.033928949865114\n 6.032952263810847\n 6.031978595303466\n 6.0310066214578395\n 6.030034177683138\n 6.029061472805756\n 6.028090703835366\n 6.027123866872981\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n1. The `zeros` function initializes a vector with zero values of the given length. This is a good way to initialize storage when you aren't worried about distinguishing non-set values from \"true\" zeroes.\n2. While normally `eachindex(t)` is preferred instead of `1:length(t)`, in this case we need to iterate only until the second-to-last index of `t` as we set the next value `T[s+1]` in the loop.\n\nThe simulated temperatures are plotted in @fig-temps:\n\n\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\np = plot(; xlabel=\"Year\", ylabel=\"Global Mean Temperature Anomaly (°C)\", legend=false) # <1>\nplot!(p, t, temps) # <2>\nxlims!(p, (1750, 2100)) # <3>\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n![Global mean temperature anomalies (in °C, relative to 1750) from 1750 to 2100 simulated using the energy balance model and RCP 8.5 forcings and parameters given in the problem statement.](hw03_files/figure-pdf/fig-temps-output-1.svg){#fig-temps fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n\n\n\n1. This syntax creates an empty plot object with the right axis labels, legend settings, etc; this is not necessary but can make the code more readable.\n2. `plot!` is different than `plot` because it adds elements to an existing plot object (in this case, `p`) rather than creating a new one. Since `p` is the last plot object created, we could have just written `plot!(t, temps)`, but adding `p` explicitly minimizes the chances of accidentally plotting onto the wrong axis.\n3. Similarly, `xlims!` changes the x limits for an existing plot object (analogously, there is also `ylims!`).\n\nFor the Monte Carlo analysis, we'll start with 10,000 samples of $\\lambda$ and see how the simulation looks.\n\n\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nn_samples = 10_000 # <1>\nλ_dist = LogNormal(log(2.1), log(2) / 4)\nλ_samples = rand(λ_dist, n_samples) # <1>\nh = histogram(λ_samples; xlabel=\"Climate Feedback Factor (°C/W/m²)\", ylabel=\"Count\", legend=false)\nvline!(h, [2.1], color=:red, linestyle=:dash) # the original value for context\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n![Samples of the climate feedback factor $\\lambda$. The red line is the deterministic value we used in the original simulation above.](hw03_files/figure-pdf/fig-samples-output-1.svg){#fig-samples fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n\n\n\n1. Creating a variable for the number of samples which can then be used later makes it easier to change the number of samples down the road without possibly creating bugs (if *e.g.* we forget to change the value everywhere).\n\nNow, simulate:\n\n\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ntemp_samples = [ebm(t, forcing_non_aerosol, forcing_aerosol, c, d, λ, α, Δt)[idx_2100] for λ in λ_samples] # <1>\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n10000-element Vector{Float64}:\n 4.250082752131921\n 3.9271173030904514\n 4.319573586572354\n 4.214336791186512\n 3.965556983548686\n 4.016195966014413\n 5.1292927884473105\n 3.89544258735652\n 4.618135058155357\n 4.649638054098068\n ⋮\n 4.167520892980213\n 6.582517364306635\n 4.251714824229311\n 4.413022632352279\n 4.367754079778502\n 5.867576008321597\n 5.175423565112294\n 4.456277811290564\n 5.176899204379472\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n1. We directly get the values of `λ` from `λ_samples` instead of looping over the indices (which is slightly slower and makes the line longer).\n\nThe expected value after this many simulations is the mean, or 4\\.68, and the 95% confidence interval is \\(4\\.67, 4\\.7\\) (using the formula for the standard error). The confidence interval around the expected value is pretty tight, but let's look at how the estimates of the mean and the confidence interval evolve over the course of the simulations to see what an \"efficient\" sample size might have been:\n\n\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n# compute running estimate of the expected value and standard deviation\n# first, pre-allocate memory for better efficiency\nT_est = zeros(n_samples) # <1>\nT_se = zeros(n_samples) # <1>\nfor i = 1:n_samples # <1>\n    T_est[i] = mean(temp_samples[1:i]) # <2>\n    if i > 1 # <3>\n        T_se[i] = std(temp_samples[1:i]) / sqrt(i)\n    end    \nend\n\np = plot(; xlabel=\"Number of Samples\", ylabel=\"Global Temperature Anomaly (°C)\", legend=false)\nplot!(p, 1:n_samples, T_est, ribbon=1.96 * T_se)\nylims!(p, (4.5, 5.0))\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n![Monte Carlo mean and 95% confidence interval of the simulated temperature in 2100 as the number of samples increases.](hw03_files/figure-pdf/fig-mc-est-output-1.svg){#fig-mc-est fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n\n\n\n1. Here we can see the benefits of setting the variable `n_samples` above; if we had hard-coded the value and needed to change it, we would also have needed to change it in all three of these lines.\n2. There are more efficient ways to do this updating, for example `T_est[i] = (T_est[i-1] * (i-1) + T_est[i]) / i`, which avoids re-computing the average for the first `i-1` simulations, but in this case it's fast enough.\n3. We can't compute the standard deviation for a single value, so we just start with `i == 2`.\n\nIf we wanted tighter confidence intervals, we could run the simulation longer (though recall the $1/\\sqrt{n}$ error law, which means to get an order of magnitude reduction, we'd need approximately 100,000 samples), but it looks from @fig-mc-est as though the estimate had stabilized around 8,000-9,000 samples, though ultimately it depends on the desired level of precision in both the estimate and the confidence interval. In this case, regardless, we're looking at an estimated temperature anomaly of around $4.7^\\circ C$ once we exceed 5,000 samples, and it isn't clear what more precision necessarily would get us.\n\n::: {.cell .markdown}\n### Problem 3 (10 points)\n\n**This problem is only required for students in BEE 5750**.\n\nA factory is planning a third wastewater discharge into the river downstream of the second plant. This discharge would consist of 5 m^3^/day of wastewater with a dissolved oxygen content of 4.5 mg/L and CBOD and NBOD levels of 50 and 45 mg/L, respectively.\n\n**In this problem**:\n\n* Assume that the treatment plan for waste stream 2 that you identified in Problem 1 is still in place for the existing discharges. If the third discharge will not be treated, under the original inflow conditions (7.5 mg/L DO), how far downstream from the second discharge does this third discharge need to be placed to keep the river concentration from dropping below 4 mg/L?\n:::\n\n#### Solution\n\nBased on how we solved Problem 1, we need to modify our solution to include a third discharge with an unknown distance from the second discharge.\n\n::: {.callout-tip}\nWe could have solved Problem 1 in a more modular way, which included multiple discharges (using a vector of tuples instead of explicitly specifying `waste1` and `waste2`, which would have made this solution simpler).\n:::\n\n\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n# do_simulate: function to simulate dissolved oxygen concentrations over the entire river\n# inputs:\n#   - d: distance between waste stream 2 and waste stream 3\n#   - inflow: tuple with inflow properties: (Volume, DO, CBOD, NBOD)\n#   - waste1: tuple with waste stream 1 properties: (Volume, DO, CBOD, NBOD)\n#   - waste2: tuple with waste stream 2 properties: (Volume, DO, CBOD, NBOD)\n#   - waste3: tuple with waste stream 3 properties: (Volume, DO, CBOD, NBOD)\n#   - C₀, B₀, N₀: initial conditions for DO, CBOD, and NBOD, respectively (mg/L)\n#   - U: velocity of river (km/d)\n#   - Cₛ = saturation oxygen concentration (mg/L)\n#   - ka, kc, kn: reaeration, CBOD decay, and NBOD decay rates, respectively (d^{-1})\nfunction do_simulate2(d, inflow, waste1, waste2, waste3, U, Cₛ, ka, kc, kn)\n    # set up ranges for each box/segment\n    x₁ = 0:1:15\n    x₂ = (15:1:15+d) .- 15 \n    x₃ = (15+d:1:50) .- (15 + d)\n\n\n    V_inflow, C_inflow, B_inflow, N_inflow = inflow\n    V_ws1, C_ws1, B_ws1, N_ws1 = waste1\n    V_ws2, C_ws2, B_ws2, N_ws2 = waste2\n    V_ws3, C_ws3, B_ws3, N_ws3 = waste2\n\n    # initialize storage for final C, B, and N\n    # need to store d=1 so the total length should be d+1\n    C = zeros(51)\n    B = zeros(51)\n    N = zeros(51)\n\n    # compute initial conditions for first segment\n    C₀ = mix_concentration(V_inflow, C_inflow, V_ws1, C_ws1)\n    B₀ = mix_concentration(V_inflow, B_inflow, V_ws1, B_ws1)\n    N₀ = mix_concentration(V_inflow, N_inflow, V_ws1, N_ws1)\n\n    # conduct first segment simulation\n    (C₁, B₁, N₁) = dissolved_oxygen(x₁, C₀, B₀, N₀, U, Cₛ, ka, kc, kn)\n    C[1:15] = C₁[1:end-1] \n    B[1:15] = B₁[1:end-1]\n    N[1:15] = N₁[1:end-1]\n\n    # compute initial conditions for second segment\n    C₀₁ = mix_concentration(V_inflow + V_ws1, C₁[end], V_ws2, C_ws2)\n    B₀₁ = mix_concentration(V_inflow + V_ws1, B₁[end], V_ws2, B_ws2)\n    N₀₁ = mix_concentration(V_inflow + V_ws1, N₁[end], V_ws2, N_ws2)\n\n    # conduct second segment simulation\n    (C₂, B₂, N₂) = dissolved_oxygen(x₂, C₀₁, B₀₁, N₀₁, U, Cₛ, ka, kc, kn)\n    C[16:16+d] = C₂ \n    B[16:16+d] = B₂\n    N[16:16+d] = N₂\n\n    # compute initial conditions for third segment\n    C₀₂ = mix_concentration(V_inflow + V_ws1 + V_ws2, C₂[end], V_ws3, C_ws3)\n    B₀₂ = mix_concentration(V_inflow + V_ws1 + V_ws2, B₂[end], V_ws3, B_ws3)\n    N₀₂ = mix_concentration(V_inflow + V_ws1 + V_ws2, N₂[end], V_ws3, N_ws3)\n\n    # conduct second segment simulation\n    (C₃, B₃, N₃) = dissolved_oxygen(x₃, C₀₂, B₀₂, N₀₂, U, Cₛ, ka, kc, kn)\n    C[16+d:end] = C₃ \n    B[16+d:end] = B₃\n    N[16+d:end] = N₃\n\n\n    return (C, B, N)\nend\n\n# set up treatment level for waste stream 2 based on solution for Problem 1\nB_ws2 = (1 - 0.15) * 45.0\nN_ws2 = (1 - 0.15) * 35.0\nwaste2 = (V_ws2, C_ws2, B_ws2, N_ws2)\n\n# set parameters for waste stream 3\nC_ws3 = 4.5\nB_ws3 = 50.0\nN_ws3 = 45.0\nV_ws3 = 5.0 * 1_000 # convert from m^3/day to L/day\nwaste3 = (V_ws3, C_ws3, B_ws3, N_ws3)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n(5000.0, 4.5, 50.0, 45.0)\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nNow we can evaluate `do_simulate2` over the different values of `d` to find the minimum value of `C`.\n\n\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n# three_discharge_minC: function to find the minimum DO concentration based on the three discharge model\n# inputs:\n#   - d: distance between waste stream 2 and waste stream 3\n#   - inflow: tuple with inflow properties: (Volume, DO, CBOD, NBOD)\n#   - waste1: tuple with waste stream 1 properties: (Volume, DO, CBOD, NBOD)\n#   - waste2: tuple with waste stream 2 properties: (Volume, DO, CBOD, NBOD)\n#   - waste3: tuple with waste stream 3 properties: (Volume, DO, CBOD, NBOD)\n#   - C₀, B₀, N₀: initial conditions for DO, CBOD, and NBOD, respectively (mg/L)\n#   - U: velocity of river (km/d)\n#   - Cₛ = saturation oxygen concentration (mg/L)\n#   - ka, kc, kn: reaeration, CBOD decay, and NBOD decay rates, respectively (d^{-1})\nfunction three_discharge_minC(d, inflow, waste1, waste2, waste3, U, Cₛ, ka, kc, kn)\n    C, B, N = do_simulate2(d, inflow, waste1, waste2, waste3, U, Cₛ, ka, kc, kn)\n    return minimum(C)\nend\n\n# evaluate over all distances from 1 to 35 m downstream using broadcasting and anonymous functions\nd = 1:1:35\nminC_d = (dist -> three_discharge_minC(dist, inflow, waste1, waste2, waste3, U, Cₛ, ka, kc, kn)).(d)\nidx = findfirst(minC_d .>= 4.0)\nmin_dist = d[idx]\n@show min_dist;\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nmin_dist = 14\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nSo, without treatment, the third discharge should be placed 14 m downstream from the second discharge.\n\n::: {.cell .markdown}\n## References\n\nList any external references consulted, including classmates.\n:::\n\n",
    "supporting": [
      "hw03_files/figure-pdf"
    ],
    "filters": []
  }
}