{
  "hash": "8dfbb9ba7f5157bac5ec73c01863bc6c",
  "result": {
    "engine": "julia",
    "markdown": "---\ntitle: \"Homework 1 Solutions\"\ndate: last-modified\nformat:\n    html:        \n        warning: true\n        error: true\n        code-annotation: \n    ipynb:\n        warning: true\n        error: true\n        code-annotation: below\n    pdf:\n        include-in-header: \n           text: |\n            \\usepackage{fvextra}\n            \\DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\\\\{\\}}\n            \\DefineVerbatimEnvironment{OutputCode}{Verbatim}{breaklines,commandchars=\\\\\\{\\}}\nexecute: \n    echo: true\nengine: julia\nformat-links: [pdf, ipynb]\n---\n\n\n\n\n\n\n\n\n## Overview\n\n\n\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nimport Pkg\nPkg.activate(@__DIR__)\nPkg.instantiate()\n```\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing Random\nusing Plots\nusing GraphRecipes\nusing LaTeXStrings\n```\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n# this sets a random seed, which ensures reproducibility of random number generation. You should always set a seed when working with random numbers.\nRandom.seed!(1)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nTaskLocalRNG()\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n## Problems (Total: 50/60 Points)\n\n### Problem 1 (15 points)\n\nThe following subproblems all involve code snippets that require debugging. For each of them:\n\n* identify and describe the logic and/or syntax error;\n* write a fixed version of the function;\n* use your fixed function to solve the problem.\n\n#### Problem 1.1\n\nThe problem is with the initialization `min_value = 0`, which means no other values can be below it. Instead, we can initialize `min_value` to be `array[1]` and start looping at index `i=2`:\n\n\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction minimum(array)\n    min_value = array[1]        # <1>\n    for i in 2:length(array)    # <1>\n        if array[i] < min_value\n            min_value = array[i]\n        end\n    end\n    return min_value\nend\n\narray_values = [89, 90, 95, 100, 100, 78, 99, 98, 100, 95]\n@show minimum(array_values);\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nminimum(array_values) = 78\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n1. Initializing `min_value` at `array[1]` ensures that we start with a candidate value; then we can loop beginning with index 2.\n\n#### Problem 1.2\n\nThere are two issues here. \n\n1. The first error is trying to access `average_grades`, which is only defined inside the `class_average()` function. This is an issue of *scope*: the variable `average_grades` doesn't exist *globally*. \n2. The second error is that `mean()` is not part of the `Base` Julia library, but rather the `Statistics` package (part of the usual Julia installation, but needs to be explicitly imported). We could import it with `using Statistics` and use `mean()`, but in this case let's just take the sum and divide by the length.\n\n\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nstudent_grades = [89, 90, 95, 100, 100, 78, 99, 98, 100, 95]\nfunction class_average(grades)\n  average_grade = sum(grades) / length(grades)\n  return average_grade\nend\n\navg_grade = class_average(student_grades) # <1>\n@show avg_grade;\n```\n\n::: {.cell-output .cell-output-stdout}\n```\navg_grade = 94.4\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n1. Now `avg_grade` exists after being assigned the output of `class_average()`. Note that we didn't reuse the name `average_grade` as that could result in strange outcomes if notebook cells were run out of order.\n\n#### Problem 1.3 \n\nThe `setindex` error comes from the use of `zero()` instead of `zeros()`:\n\n* [`zero(n)`](https://docs.julialang.org/en/v1/base/numbers/#Base.zero) creates a zero variable of the same type of the argument `n` (*e.g.* `zero(1)` is `0` and `zero(1.5)` is `0.0`).\n* [`zeros(n)`](https://docs.julialang.org/en/v1/base/arrays/#Base.zeros) creates an array of zeroes of dimension `n`, where `n` can be an integer or a tuple (for a matrix or higher-dimensional array).\n\nAs a result, the original call `outcomes = zero(n_trials)` sets `outcomes=0`, but then when we try to set `outcomes[1]` in the loop, this is undefined as a scalar does not have an index, resulting in the error.\n\n\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction passadieci()\n    # this rand() call samples 3 values from the vector [1, 6]\n    roll = rand(1:6, 3) \n    return roll\nend\nn_trials = 1_000\noutcomes = zeros(n_trials) # <1>\nfor i = 1:n_trials\n    outcomes[i] = (sum(passadieci()) > 11) # <2>\nend\nwin_prob = sum(outcomes) / n_trials # compute average number of wins\n@show win_prob;\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nwin_prob = 0.374\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n1. Changed `zero` to `zeroes`; note that it's generally preferable to initialize an array of the desired size instead of creating an empty vector and using `append`, as that approach can get quite slow as the number of `append` calls increases. \n2. Now that `outcomes` is a vector, we can access its indexed values.\n\nWe could also use [comprehensions](https://viveks.me/environmental-systems-analysis/tutorials/julia-basics.html#comprehensions) and [broadcasting](https://docs.julialang.org/en/v1/manual/arrays/#Broadcasting) (applying a function across each element of an array) instead of initializing `outcomes` as a zero vector and looping to fill it:\n\n\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nrolls = [passadieci() for i in 1:n_trials] # <1>\noutcomes = sum.(rolls) .> 11 # <2>\n\nwin_prob = sum(outcomes) / n_trials # compute average number of wins\n@show win_prob;\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nwin_prob = 0.364\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n1. This is an example of a *comprehension*, which is an inline loop that produces an array; the advantage is that this is sometimes more readable than an explicit loop when the in-loop commands are short. \n2. This is an example of *broadcasting* (actually twice), indicated by the use of the decimal `.` in function calls. `sum.(v)` applies the function `sum` to every element of `v`, so that adds each of the individual roll vectors to get the sum of those three dice, and `.>` does an element-wise comparison of each of those sums to `11`. You would get an error if you tried `sum.(rolls) > 11` because Julia does not want to make assumptions about your intent in comparing a vector with a scalar.\n\n### Problem 2 (5 points)\n\nLet's outline the steps in `mystery_function`:\n\n1. Initialize an empty vector.\n2. If a value `v` is not already in `y`, add `v` to `y`.\n3. Return after looking at all values.\n\nThis means that `mystery_function` selects and returns the unique values in `values`, which is confirmed by the test case.\n\nThere are many ways to add comments, but we could comment as follows:\n\n\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n# mystery_function: \n#    Inputs: \n#       - values: vector of numeric values\n#    Outputs: \n#       - vector of unique values from the input \nfunction mystery_function(values)\n    y = [] # initialize as an empty vector because we don't know how many values we will end up with\n    for v in values\n        if !(v in y) # if a value is not already in y\n            append!(y, v) # append to y\n        end\n    end\n    return y\nend\n\nlist_of_values = [1, 2, 3, 4, 3, 4, 2, 1]\n@show mystery_function(list_of_values);\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nmystery_function(list_of_values) = Any[1, 2, 3, 4]\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nThe built-in Julia function which does the same thing is `unique()` (found using a Google search for \"unique Julia vector function\").\n\n\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n@show unique(list_of_values);\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nunique(list_of_values) = [1, 2, 3, 4]\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n### Problem 3 (10 points)\n\nYou're interested in writing some code to remove the mean of a vector. \n\n* Write a function `compute_mean(v)` which sums all of the elements of a vector `v` using a `for` loop and computes the mean. \n* Make a random vector `random_vect` of length 10 using Julia's `rand()` function. Use your `compute_mean()` function to calculate its mean and subtract it from `random_vect` **without a loop** (using a Julia technique called *broadcasting*; feel free to consult the Julia documentation and search as necessary). Check that the new vector has mean zero.\n\nOur `compute_mean` function should:\n\n1. Initialize a running sum at 0;\n2. Loop over all elements of `v`;\n3. Add each element in turn to the running sum;\n4. Divide the running sum by the number of elements and return.\n\n\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction compute_mean(v)\n    v_sum = 0\n    for val in v\n        v_sum += val\n    end\n    return v_sum / length(v)\nend\n\nrandom_vect = rand(10)\nrand_mean = compute_mean(random_vect)\n@show rand_mean;\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nrand_mean = 0.3573789691628376\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nTo subtract off the mean from `random_vect`, we can broadcast the subtraction operator by putting a decimal in front: `.-`.^[As a reminder, broadcasting involves applying a function element-wise. If we just tried to subtract `random_vect - rand_mean`, Julia would throw an error because it doesn't know if it should try element-wise subtraction or if we made a mistake in trying to subtract a scalar from a vector, and Julia's design is to err on the side of throwing an error unless we specifically say that we want an element-wise operation through broadcasting.]\n\n\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nrandom_vect_demean = random_vect .- rand_mean\n@show compute_mean(random_vect_demean);\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncompute_mean(random_vect_demean) = 2.2204460492503132e-17\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nWe have produced a mean-zero random vector! But this isn't *exactly* zero due to numerical precision. This doesn't really matter, as the non-zero entries are insignificant digits, which we can see if we round (which we should do anyway):\n\n\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n@show round(compute_mean(random_vect_demean); digits=1); # <1>\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nround(compute_mean(random_vect_demean); digits = 1) = 0.0\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n1. The `round(y; digits=n)` function rounds `y` to `n` digits after the decimal place, defaulting to `n=0` (which rounds to the nearest integer, though printing a decimal due to the *type* of the variable).\n\n### Problem 4 (20 points)\n\nThese equations will be derived in terms of $X_1$ (the land disposal amount, in kg/day) and $X_2$ (the chemically treated amount, in kg/day), where $X_1 + X_2 \\leq 100\\ \\mathrm{kg/day}$. Note that we don't need to explicitly represent the amount of directly disposed YUK, as this is $100 - X_1 - X_2$ and so is not a free variable.\n\n\n\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nA = [0 1 1 1;\n\t0 0 0 1;\n\t0 0 0 1;\n\t0 0 0 0]\n\nnames = [\"Plant\", \"Land Treatment\", \"Chem Treatment\", \"Pristine Brook\"]\n# modify this dictionary to add labels\nedge_labels = Dict((1, 2) => L\"X_1\", (1,3) => L\"X_2\", (1, 4) => L\"100 - X_1 - X_2\", (2, 4) => L\"0.2X_1\",(3, 4) => L\"0.005X_2^2\")\nshapes=[:hexagon, :rect, :rect, :hexagon]\nxpos = [0, -1.5, -0.25, 1]\nypos = [1, 0, 0, -1]\n\np = graphplot(A, names=names,edgelabel=edge_labels, markersize=0.15, markershapes=shapes, markercolor=:white, x=xpos, y=ypos)\ndisplay(p)\n```\n\n::: {.cell-output .cell-output-display}\n![System diagram of the wastewater treatment options in Problem 4.](hw01_files/figure-pdf/fig-wastewater-output-1.svg){#fig-wastewater fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\nThe amount of YUK which will be discharged is\n\n\\begin{align*}\nD(X_1, X_2) &= 100 - X_1 - X_2 + 0.2 X_1 + 0.005X_2^2 \\\\\n&= 100 - 0.8 X_1 + (0.005X_2 - 1)X_2 \\\\\n&= 100 - 0.8 X_1 + 0.005 X_2^2 - X_2\n\\end{align*}\n\nThe cost is\n$$\nC(X_1, X_2) = X_1^2/20 + 1.5 X_2.\n$$\n\nA Julia function for this model could look like:\n\n\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n# we will assume that X₁, X₂ are vectors so we can vectorize\n# the function; hence the use of broadcasting. This makes unpacking\n# the different outputs easier as each will be returned as a vector.\n# Note that even though this is vectorized, passing scalar inputs\n# will still work fine.\nfunction yuk_discharge(X₁, X₂)\n    # Make sure X₁ + X₂ <= 100! Throw an error if not.\n    if any(X₁ .+ X₂ .> 100) # <1>\n        error(\"X₁ + X₂ must be less than 200\")\n    end\n    yuk = 100 .- 0.8X₁ .+ (0.005X₂ .- 1) .* X₂ # <2>\n    cost = X₁.^2/20 .+ 1.5X₂\n    return (yuk, cost)\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nyuk_discharge (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n1. Checking for these kinds of errors is useful when there are hard limits on what arguments can be passed in. This syntax lets you throw an error which says something is going wrong in the code. In general, Julia style is to try to do a computation and throw an error if something goes wrong.\n2. We use broadcasting here to work on vectors of arguments for efficiency. This is in no way required.\n\nNow, let's experiment with different outcomes.^[We left this intentionally open for you to conceptualize how to generate combinations and to look into different ways of implementing these in Julia. For a more systematic approach, we can sample combinations from a [Dirichlet distribution](https://en.wikipedia.org/wiki/Dirichlet_distribution), which samples combinations which add up to 1. This will require installing and loading the `Distributions.jl` package (we will spend more time working with `Distributions.jl` later).] Some other options include just randomly sampling values (but be careful of not sampling impossible combinations of $X_1$ and $X_2$), manually searching, or setting up a grid of combinations.\n\n\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n# Install and load Distributions.jl\nPkg.add(\"Distributions\") # <1>\nusing Distributions # <1>\n\nyuk_distribution = Dirichlet(3, 1) # <2>\n# Need to scale samples from 0 to 200, not 0 to 1\nyuk_samples = 100 * rand(yuk_distribution, 1000)\nD, C = yuk_discharge(yuk_samples[1,:], yuk_samples[2, :])\n\n# Plot the discharge vs. cost and add a line for the regulatory limit\np = scatter(D, C, markersize=2, label=\"Treatment Samples\") # <3>\nvline!(p, [20], color=:red, label=\"Regulatory Limit\") # <4>\n# Label axes\nxaxis!(p, \"YUK Discharge (kg/day)\") # <5>\n# For the y-axis label, we need to \"escape\" the $ by adding a slash\n# otherwise it interprets that as starting math mode\nyaxis!(p, \"Treatment Cost (\\$/day)\") # <5>\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Resolving package versions...\n  No Changes to `~/Teaching/BEE4750/website/solutions/hw01/Project.toml`\n  No Changes to `~/Teaching/BEE4750/website/solutions/hw01/Manifest.toml`\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n![Sampled solutions for the wastewater allocation problem in Problem 4, showing cost vs. YUK concentration. The red line marks the regulatory discharge limit of 20kg/day.](hw01_files/figure-pdf/fig-yuk-solution-output-2.svg){#fig-yuk-solution fig-align='center' fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n\n\n\n1. This is how we add new packages that are not in the existing environment and then load them.\n2. The Dirichlet distribution is over combinations of values which add up to 1, which is what we want for shares of the total YUK discharge. The 3D Dirichlet distribution with parameters equal to 1 is basically uniform over these combinations. See: <https://juliastats.org/Distributions.jl/stable/multivariate/#Distributions.Dirichlet>.\n3. This is a basic scatter plot with a label for the plot elements. If we wanted to turn the legend off in any plot, use `legend=false` as an argument.\n4. This is how to add a vertical line to a plot with a label. The syntax for a horizontal line is `hline(...)`. The `!` at the end of `vline!()` is important: this is standard Julia syntax to distinguish commands which *mutate* (or change) their input (in this case, the first argument `p`, the plot object), as this is not always desirable behavior.\n5. This is how to change axis labels. Notice that this also mutates the input plot.\n\nWe can see that there are a few treatment strategies which comply with the limit, but they are fairly expensive. This is an example of a *tradeoff* between two objectives^[More on this later in the semester!], where one has to make a choice between what objectives to prioritize. But one thing to note is that just choosing an expensive strategy does not guarantee compliance.\n\n### Problem 5 (10 points)\n\n#### Problem 5.1\n\nHere is one solution: Julia includes a function `iseven()` which returns 1 if the argument is even and 0 if it is odd. So we can use a comprehension to evaluate `!iseven(x)` (the `!` is Boolean negation) over the range `0:149`, which will return a vector of 1s and 0s, and then add up the vector to get the count of odd numbers. Another approach could be to use the `isodd()` function directly.\n\n\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nodd_count = sum([!iseven(x) for x in 0:149])\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n75\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n#### Problem 5.2\n\n\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction polynomial(x, a)\n    p = 0 # initialize value of polynomial\n    for i in eachindex(a) # <1>\n        p += a[i] * x^(i-1) # <2>\n    end\n    return p\nend\n\na = [1, 0, -1, 2]\nx = 2\n@show polynomial(x, a); # <3>\n```\n\n::: {.cell-output .cell-output-stdout}\n```\npolynomial(x, a) = 13\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n1. `for i in eachindex(a)` is the same thing as `for i = 1:length(a)` (iterating over the indices of `a`) but is preferred in Julia to provide more flexibility with how the array `a` is indexed, such as for multidimensional arrays. There is also `for b in a` which iterates over the values in `a` rather than the indices, and `for (i, b) in pairs(a)` which iterates over both the indices and values without requiring the line `b = a[i]`.\n2. Julia indexing starts at 1, so `i=1` corresponds to the constant term, or a power of 0.\n3. The `@show` macro formats the output of the command nicely and prints it; the semi-colon at the end suppresses the normal output of the notebook cell, which is printed by default without the semi-colon.\n\n",
    "supporting": [
      "hw01_files/figure-pdf"
    ],
    "filters": []
  }
}